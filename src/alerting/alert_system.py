"""
Alert System Module

Handles various types of alerts for anomaly detection including email, webhooks, and Prometheus metrics.
"""

import smtplib
import json
import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, List, Optional
from datetime import datetime
import yaml
import logging
import asyncio
from abc import ABC, abstractmethod
import threading
import time
from prometheus_client import Counter, Histogram, Gauge, start_http_server
from collections import defaultdict, deque


class AlertHandler(ABC):
    """Abstract base class for alert handlers."""
    
    @abstractmethod
    def send_alert(self, alert: Dict) -> bool:
        """Send an alert. Returns True if successful."""
        pass


class EmailAlertHandler(AlertHandler):
    """Email alert handler using SMTP."""
    
    def __init__(self, config: Dict):
        self.smtp_server = config.get('smtp_server', 'localhost')
        self.smtp_port = config.get('smtp_port', 587)
        self.sender = config.get('sender', 'alerts@loglens.ai')
        self.password = config.get('password', '')
        self.recipients = config.get('recipients', [])
        self.use_tls = config.get('use_tls', True)
        
        self.logger = logging.getLogger(__name__)
    
    def send_alert(self, alert: Dict) -> bool:
        """Send email alert."""
        try:
            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.sender
            msg['To'] = ', '.join(self.recipients)
            msg['Subject'] = f"ðŸš¨ LogLens Anomaly Alert - {alert.get('timestamp', 'Unknown')}"
            
            # Create email body
            body = self._create_email_body(alert)
            msg.attach(MIMEText(body, 'html'))
            
            # Send email
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            if self.use_tls:
                server.starttls()
            
            if self.password:
                server.login(self.sender, self.password)
            
            text = msg.as_string()
            server.sendmail(self.sender, self.recipients, text)
            server.quit()
            
            self.logger.info(f"Email alert sent to {', '.join(self.recipients)}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to send email alert: {e}")
            return False
    
    def _create_email_body(self, alert: Dict) -> str:
        """Create HTML email body."""
        detection_methods = ', '.join(alert.get('detection_methods', []))
        
        html = f"""
        <html>
        <body>
            <h2 style="color: red;">ðŸš¨ LogLens Anomaly Detected</h2>
            
            <table style="border-collapse: collapse; width: 100%;">
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;"><strong>Timestamp</strong></td>
                    <td style="border: 1px solid #ddd; padding: 8px;">{alert.get('timestamp', 'Unknown')}</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;"><strong>File Path</strong></td>
                    <td style="border: 1px solid #ddd; padding: 8px;">{alert.get('file_path', 'Unknown')}</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;"><strong>Detection Methods</strong></td>
                    <td style="border: 1px solid #ddd; padding: 8px;">{detection_methods}</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;"><strong>Log Message</strong></td>
                    <td style="border: 1px solid #ddd; padding: 8px; font-family: monospace; background-color: #f9f9f9;">
                        {alert.get('message', 'No message')}
                    </td>
                </tr>
            </table>
            
            <h3>Detection Details</h3>
            <pre style="background-color: #f9f9f9; padding: 10px; border: 1px solid #ddd;">
{json.dumps(alert.get('details', {}), indent=2)}
            </pre>
            
            <p><em>This alert was generated by LogLens AI-Powered Log Anomaly Detection System.</em></p>
        </body>
        </html>
        """
        return html


class WebhookAlertHandler(AlertHandler):
    """Webhook alert handler for integrations like Slack, Teams, etc."""
    
    def __init__(self, config: Dict):
        self.url = config.get('url', '')
        self.headers = config.get('headers', {'Content-Type': 'application/json'})
        self.timeout = config.get('timeout', 10)
        self.template = config.get('template', 'slack')  # slack, teams, generic
        
        self.logger = logging.getLogger(__name__)
    
    def send_alert(self, alert: Dict) -> bool:
        """Send webhook alert."""
        try:
            payload = self._create_payload(alert)
            
            response = requests.post(
                self.url,
                json=payload,
                headers=self.headers,
                timeout=self.timeout
            )
            
            if response.status_code == 200:
                self.logger.info("Webhook alert sent successfully")
                return True
            else:
                self.logger.error(f"Webhook alert failed with status {response.status_code}")
                return False
                
        except Exception as e:
            self.logger.error(f"Failed to send webhook alert: {e}")
            return False
    
    def _create_payload(self, alert: Dict) -> Dict:
        """Create webhook payload based on template."""
        detection_methods = ', '.join(alert.get('detection_methods', []))
        
        if self.template == 'slack':
            return {
                "text": "ðŸš¨ LogLens Anomaly Alert",
                "blocks": [
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"*ðŸš¨ LogLens Anomaly Detected*\n\n*Timestamp:* {alert.get('timestamp', 'Unknown')}\n*File:* `{alert.get('file_path', 'Unknown')}`\n*Detection Methods:* {detection_methods}"
                        }
                    },
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"*Log Message:*\n```{alert.get('message', 'No message')}```"
                        }
                    }
                ]
            }
        
        elif self.template == 'teams':
            return {
                "@type": "MessageCard",
                "@context": "http://schema.org/extensions",
                "themeColor": "ff0000",
                "summary": "LogLens Anomaly Alert",
                "sections": [
                    {
                        "activityTitle": "ðŸš¨ LogLens Anomaly Detected",
                        "facts": [
                            {"name": "Timestamp", "value": alert.get('timestamp', 'Unknown')},
                            {"name": "File Path", "value": alert.get('file_path', 'Unknown')},
                            {"name": "Detection Methods", "value": detection_methods},
                            {"name": "Log Message", "value": alert.get('message', 'No message')}
                        ]
                    }
                ]
            }
        
        else:  # generic
            return {
                "alert_type": "anomaly",
                "timestamp": alert.get('timestamp'),
                "file_path": alert.get('file_path'),
                "message": alert.get('message'),
                "detection_methods": alert.get('detection_methods', []),
                "details": alert.get('details', {})
            }


class PrometheusMetricsHandler:
    """Prometheus metrics handler for monitoring and alerting."""
    
    def __init__(self, config: Dict):
        self.port = config.get('port', 8000)
        self.enabled = config.get('enabled', True)
        
        if self.enabled:
            # Define metrics
            self.anomaly_counter = Counter(
                'loglens_anomalies_total',
                'Total number of anomalies detected',
                ['detection_method', 'file_path']
            )
            
            self.log_processing_histogram = Histogram(
                'loglens_log_processing_seconds',
                'Time spent processing logs'
            )
            
            self.active_monitors_gauge = Gauge(
                'loglens_active_monitors',
                'Number of active log monitors'
            )
            
            self.logs_processed_counter = Counter(
                'loglens_logs_processed_total',
                'Total number of logs processed',
                ['file_path']
            )
            
            self.logger = logging.getLogger(__name__)
            
            # Start Prometheus metrics server
            start_http_server(self.port)
            self.logger.info(f"Prometheus metrics server started on port {self.port}")
    
    def record_anomaly(self, alert: Dict):
        """Record anomaly metrics."""
        if not self.enabled:
            return
        
        file_path = alert.get('file_path', 'unknown')
        detection_methods = alert.get('detection_methods', ['unknown'])
        
        for method in detection_methods:
            self.anomaly_counter.labels(
                detection_method=method,
                file_path=file_path
            ).inc()
    
    def record_logs_processed(self, count: int, file_path: str = 'unknown'):
        """Record processed logs metrics."""
        if not self.enabled:
            return
        
        self.logs_processed_counter.labels(file_path=file_path).inc(count)
    
    def set_active_monitors(self, count: int):
        """Set number of active monitors."""
        if not self.enabled:
            return
        
        self.active_monitors_gauge.set(count)
    
    def time_processing(self):
        """Context manager for timing log processing."""
        if not self.enabled:
            return nullcontext()
        
        return self.log_processing_histogram.time()


class AlertSystem:
    """Main alert system that coordinates different alert handlers."""
    
    def __init__(self, config_path: str = "config/config.yaml"):
        # Load configuration
        with open(config_path, 'r') as f:
            self.config = yaml.safe_load(f)
        
        self.handlers: List[AlertHandler] = []
        self.metrics_handler: Optional[PrometheusMetricsHandler] = None
        self.alert_history = deque(maxlen=1000)
        self.alert_stats = defaultdict(int)
        self.rate_limiter = {}  # For rate limiting alerts
        
        self.logger = logging.getLogger(__name__)
        
        # Initialize handlers
        self._initialize_handlers()
    
    def _initialize_handlers(self):
        """Initialize all configured alert handlers."""
        alerting_config = self.config.get('alerting', {})
        
        # Email handler
        if alerting_config.get('email', {}).get('enabled', False):
            email_handler = EmailAlertHandler(alerting_config['email'])
            self.handlers.append(email_handler)
            self.logger.info("Email alert handler initialized")
        
        # Webhook handler
        if alerting_config.get('webhook', {}).get('enabled', False):
            webhook_handler = WebhookAlertHandler(alerting_config['webhook'])
            self.handlers.append(webhook_handler)
            self.logger.info("Webhook alert handler initialized")
        
        # Prometheus metrics
        if alerting_config.get('prometheus', {}).get('enabled', False):
            self.metrics_handler = PrometheusMetricsHandler(alerting_config['prometheus'])
            self.logger.info("Prometheus metrics handler initialized")
    
    def send_alert(self, alert: Dict):
        """Send alert through all configured handlers."""
        # Add to history
        self.alert_history.append({
            **alert,
            'sent_at': datetime.now().isoformat()
        })
        
        # Check rate limiting
        if self._is_rate_limited(alert):
            self.logger.info("Alert rate limited, skipping")
            return
        
        # Update statistics
        for method in alert.get('detection_methods', []):
            self.alert_stats[method] += 1
        
        # Record metrics
        if self.metrics_handler:
            self.metrics_handler.record_anomaly(alert)
        
        # Send through all handlers
        success_count = 0
        for handler in self.handlers:
            try:
                if handler.send_alert(alert):
                    success_count += 1
            except Exception as e:
                self.logger.error(f"Error in alert handler {type(handler).__name__}: {e}")
        
        self.logger.info(f"Alert sent through {success_count}/{len(self.handlers)} handlers")
        
        # Update rate limiter
        self._update_rate_limiter(alert)
    
    def _is_rate_limited(self, alert: Dict) -> bool:
        """Check if alert should be rate limited."""
        # Simple rate limiting based on message similarity
        message = alert.get('message', '')
        current_time = time.time()
        
        # Remove old entries
        cutoff_time = current_time - 300  # 5 minutes
        self.rate_limiter = {
            msg: timestamp for msg, timestamp in self.rate_limiter.items()
            if timestamp > cutoff_time
        }
        
        # Check if similar message was recently sent
        for prev_message, timestamp in self.rate_limiter.items():
            if self._messages_similar(message, prev_message):
                return True
        
        return False
    
    def _update_rate_limiter(self, alert: Dict):
        """Update rate limiter with new alert."""
        message = alert.get('message', '')
        self.rate_limiter[message] = time.time()
    
    def _messages_similar(self, msg1: str, msg2: str, threshold: float = 0.8) -> bool:
        """Check if two messages are similar (simple word overlap)."""
        words1 = set(msg1.lower().split())
        words2 = set(msg2.lower().split())
        
        if not words1 or not words2:
            return False
        
        intersection = len(words1.intersection(words2))
        union = len(words1.union(words2))
        
        similarity = intersection / union if union > 0 else 0
        return similarity >= threshold
    
    def get_alert_stats(self) -> Dict:
        """Get alert statistics."""
        total_alerts = len(self.alert_history)
        recent_alerts = sum(
            1 for alert in self.alert_history
            if (datetime.now() - datetime.fromisoformat(alert['sent_at'])).total_seconds() < 3600
        )
        
        return {
            'total_alerts': total_alerts,
            'recent_alerts_1h': recent_alerts,
            'alerts_by_method': dict(self.alert_stats),
            'handlers_configured': len(self.handlers),
            'metrics_enabled': self.metrics_handler is not None
        }
    
    def get_recent_alerts(self, count: int = 50) -> List[Dict]:
        """Get recent alerts."""
        return list(self.alert_history)[-count:]


# Null context manager for Python < 3.7
class nullcontext:
    def __enter__(self):
        return None
    def __exit__(self, *excinfo):
        pass


def main():
    """Example usage of the alert system."""
    # Sample alert
    sample_alert = {
        'timestamp': datetime.now().isoformat(),
        'file_path': '/var/log/application.log',
        'message': 'CRITICAL: Multiple failed login attempts from 203.0.113.45 - 15 attempts',
        'detection_methods': ['BERT', 'Rule-based'],
        'details': {
            'bert': {'confidence': 0.95, 'anomaly_prob': 0.92},
            'rule_based': {'anomaly_keyword_count': 2, 'log_level_severity': 7}
        }
    }
    
    # Initialize alert system
    alert_system = AlertSystem()
    
    # Send test alert
    print("Sending test alert...")
    alert_system.send_alert(sample_alert)
    
    # Show stats
    stats = alert_system.get_alert_stats()
    print(f"Alert stats: {stats}")


if __name__ == "__main__":
    main()